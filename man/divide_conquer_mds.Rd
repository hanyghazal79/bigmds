% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/divide_conquer_mds.R
\name{divide_conquer_mds}
\alias{divide_conquer_mds}
\title{Divide and Conquer MDS}
\usage{
divide_conquer_mds(x, l, tie, k, dist_fn = stats::dist, ...)
}
\arguments{
\item{x}{A matrix with n individuals (rows) and q variables (columns).}

\item{l}{The largest value which allows classical MDS to be computed efficiently, i.e, the largest value which makes
\code{cmdscale()} be run without any computational issues.}

\item{tie}{Number of points used to align the MDS solutions obtained by the division of \code{x} into p submatrices.
Recommended value: \code{2Â·k}.}

\item{k}{Number of principal coordinates to be extracted.}

\item{dist_fn}{Distance function to be used for obtaining a MDS configuration.}

\item{...}{Further arguments passed to \code{dist_fn} function.}
}
\value{
Returns a list containing the following elements:
\describe{
\item{points}{A matrix that consists of n individuals (rows) and \code{k} variables (columns) corresponding to the
MDS coordinates.}
\item{eigen}{The first \code{k} eigenvalues.}
}
}
\description{
Performs \emph{Multidimensional Scaling} for big datasets using a Divide and Conquer strategy. This method can
compute a MDS configuration even when the dataset is so large that classical MDS methods (\code{cmdscale}) can not be run
due to computational problems.
}
\details{
In order to obtain a MDS configuration for the entire matrix \code{x}, it is needed to break the dataset into
p submatrices (\emph{Divide and Conquer strategy}).

In order to obtain p, \code{tie} and \code{l} are taken into account: p=n/\code{(l-tie)}. This allows to use
\code{cmdscale} function in every submatrix.

Given a MDS solution, any rotation is another (valid) MDS solution. It means that every partition has its
own coordinate system.

In order to keep the same coordinate system, every two consecutive submatrices are forced to share \code{tie}
points. These points are used to align the corresponding MDS configurations. Such an alignment is performed by means
of Procrustes.
}
\examples{
set.seed(42)
x <- matrix(data = rnorm(4*10000), nrow = 10000) \%*\% diag(c(15, 10, 1, 1))
mds <- divide_conquer_mds(x = x, l = 200, tie = 2*2, k = 2, dist_fn = stats::dist)
head(cbind(mds$points, x[, 1:2]))
var(x)
var(mds$points)
}
\references{
Delicado P. and C. Pachon-Garcia (2020). \emph{Multidimensional Scaling for Big Data}.
\url{https://arxiv.org/abs/2007.11919}

Borg I and P. Groenen (1997). \emph{Modern Multidimensional Scaling: Theory and Applications}. New York: Springer. pp. 340-342.
}
